#!/bin/bash

# Fonctions

function PrintHelp ()
{
	echo
	echo "Usage : morning [OPTION]..."
	echo ----------------------------
	echo
	echo "	-n				   Used to write a message to print to tomorrow."
	echo "						 Can be used with a positive integer to"
	echo "						 report the message by the number of days"
	echo
	echo "		--help		   Display this help and exit"
	echo
}

function MorningRoutine () 
{
	echo ----------------------------
	date
	echo ----------------------------
	if [ "${isportable}" = true ]; then
		echo Portable mode
	fi
	
	if [ -s "$commandsfile" ]; then

		echo
		echo Executing commands
		echo ------------------
		if [ -f "$commandsfile" ]; then
			if [ -x "$commandsfile" ]; then

				bash $commandsfile
	
				# Execute user defined commands
				# will have to implement way to execute said script and to edit it	
			else
				echo "ERROR : $commandsfile is not executable."
			fi
		else
			echo "ERROR : $commandsfile is not a regular file."
			echo "Is the path to commandsfile a folder ?"
			echo "Please use complete path with the file name at the end."
		fi
	fi
	
	if [ -s "$remindersfile" ]; then

		echo 
		echo Reminders
		echo -------------------
		if [ -f "$remindersfile" ];then
			if [ -r "$remindersfile" ]; then
				
				echo $(cat $remindersfile)
				# Print user defined daily reminders
				# will have to implement a way to edit reminders
			else
				echo "ERROR : $remindersfile cannot be read."
			fi
		else
			echo "ERROR : $remindersfile is not a regular file."
			echo "Is the path to remindersfile a folder ?"
			echo "Please use complete path with the file name at the end."
		fi
	fi

	filename="${pathtofiles}Morning_${year}_${month}_${day}.txt"

	echo
	echo Message for you
	echo ---------------

	# Print message for the day

	if [ -s "$filename" ]; then
		if [ -r "$filename" ]; then
			cat "$filename"
			echo
		else
			echo "ERROR : $filename cannot be read."
		fi
	else
		echo No messages to display
	fi
}

function CreateFile ()
{
	# Creating the name of the file
	textarray=()
	local nextday
	local nextmonth
	local nextyear

	# Add number of days requested or the default of one
	if [ $# -eq 1 ]; then
    	nextday=$(date --date="$1 day" +%d)
    	nextmonth=$(date --date="$1 day" +%m)
    	nextyear=$(date --date="$1 day" +%Y)
	else
    	nextday=$(date --date="1 day" +%d)
    	nextmonth=$(date --date="1 day" +%m)
    	nextyear=$(date --date="1 day" +%Y)
	fi

	filename="${pathtofiles}Morning_${nextyear}_${nextmonth}_${nextday}.txt"

	# Read text
	read -p $'Enter text (enter eol to end): \n' text
	while [ "$text" != "eol" ] && [ "$text" != "EOL" ]
	do
		textarray+=("$text")
		read text
	done

		# If array is empty do not create file
	if [ "${#textarray[@]}" -ne 0 ]; then
	
		# Write text to array
		for i in "${textarray[@]}"
		do
			echo $i >> "$filename"
		done

	fi
}

function CleanMessages ()
{
	# Will have to update to work with new paths
	listMornings=($(ls -1 ${pathtofiles} | egrep 'Morning_[0-9]{4}_[0-9]{2}_[0-9]{2}.txt'))

	echo
	
	for file in "${listMornings[@]}"
	do

		fileyear=$(echo "$file" | cut -d '_' -f2)
		filemonth=$(echo "$file" | cut -d '_' -f3)
		fileday=$(echo "$file" | cut -d '_' -f4 | cut -d '.' -f1)
		
		# Check if message file is older than the current date
		if [ "$fileyear" -lt "$year" ]; then
			# Delete file
			rm "${pathtofiles}${file}"

		elif [ "$fileyear" -eq "$year" ]; then
 
			if [ "$filemonth" -lt "$month" ]; then
				# Delete file
				rm "${pathtofiles}${file}"

			elif [ "$filemonth" -eq "$month" ]; then

				if [ "$fileday" -lt "$day" ]; then
					# Delete file
					rm "${pathtofiles}${file}"
				fi
			fi
		fi

	done
}

function PathGathering ()
{
	pathtofiles="filepathnotset"
	remindersfile="filepathnotset"
	commandsfile="filepathnotset"
	
	# Check config for paths
	if [ "$isportable" = true ]; then
		pathtoconfig="morning.conf"
	else
		pathtoconfig="${HOME}/morning/morning.conf"
	fi
	
	ConfigLoading

	# Paths should be loaded but put defaults if not
	if [ "$pathtofiles" == "filepathnotset" ]; then
		if [ "$isportable" = true ]; then
			pathtofiles=""
		else
			pathtofiles="${HOME}/morning/"
		fi
	fi

	if [ "$remindersfile" == "filepathnotset" ]; then
		if [ "$isportable" = true ]; then
			remindersfile="reminders.txt"
		else
			remindersfile="${pathtofiles}reminders.txt"
		fi
	fi

	if [ "$commandsfile" == "filepathnotset" ]; then
		if [ "$isportable" = true ]; then
			commandsfile="commands"
		else
			commandsfile="${pathtofiles}commands"
		fi
	fi

	# Need to confirm that paths are absolute in Installed and relative in portable
	if [ "$isportable" = true ]; then
		if [[ $pathtofiles =~ ^/.* ]] || [[ $remindersfile =~ ^/.* ]] || [[ $commandsfile =~ ^/.* ]]; then
			echo
			echo "CONFIG ERROR : pathtofiles, remindersfile and commandsfile should be relative paths to be portable"
			echo
		fi
	else
		if ! [[ $pathtofiles =~ ^/.* ]] || ! [[ $remindersfile =~ ^/.* ]] || ! [[ $commandsfile =~ ^/.* ]]; then
			echo
			echo "CONFIG ERROR : pathtofiles, remindersfile and commandsfile should be absolute paths when installed"
			echo
		fi	
	fi
}

function CreateConfig ()
{
	touch "$pathtoconfig"

	if [ -e "$pathtoconfig" ]; then
		if [ -w "$pathtoconfig" ]; then
			# This will push default values for all paths
			echo '# This is the morning command configuration file' >> "$pathtoconfig"
			echo 'remindersfile="filepathnotset"' >> "$pathtoconfig"
			echo 'commandsfile="filepathnotset"' >> "$pathtoconfig"
			echo 'pathtofiles="filepathnotset"' >> "$pathtoconfig"
			return 0
		else
			echo "ERROR : could not write default config in $pathtoconfig"
			return 1
		fi
	else
		echo "ERROR : could not create $pathtoconfig"
		return 1
	fi
}

function ConfigLoading ()
{
	# First test if config file is present
	if [ -e "$pathtoconfig" ]; then
		if [ -r "$pathtoconfig" ]; then
			source "$pathtoconfig"
		else
			echo "ERROR : $pathtoconfig cannot be read."
		fi
	else
		# Try to create the config
		CreateConfig

		if [ "$?" -eq 0 ]; then
			# This is a security risk because it can execute code
			source "$pathtoconfig"
		fi
	fi
}

function SetDate ()
{	
	day=$(date +%d)
	month=$(date +%m)
	year=$(date +%Y)
}

InstalledOrPortable ()
{
	# Script should always be executed from /usr/bin from the PATH
	# if it is not, it assumes it is in portable mode and will take all of its files from the executing folder
	
	# Does not work on OSX
	local pathtoscript1=$(dirname `which $0`)
	# Should work on OSX found at http://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
	local pathtoscript2="$( cd "$(dirname "$0")" ; pwd -P )"
	
	if [ "$pathtoscript1" != "$pathtoscript2" ]; then
		echo
		echo Path to script is unclear please contact owner at PUT GITHUB LINK
		echo Please add this information to your bugtrack with your OS
		echo ----------------------------------------------------------------
		echo Path mismatch :
		echo "pathtoscript1 = $pathtoscript1"
		echo "pathtoscript2 = $pathtoscript2"
		echo ----------------------------------------------------------------
		echo
	else	
		pathtoscript="$pathtoscript2"
		
		if [ "$pathtoscript" != '/usr/bin' ]; then
			isportable=true
		else
			isportable=false
		fi
	fi
}

# Initialisation

InstalledOrPortable
PathGathering
SetDate

# Arguments parsing

if [ $# -eq 0 ]; then
	# Run daily commands
	MorningRoutine
	# Clean message folder of older messages
	CleanMessages
else
	if [ $# -gt 2 ]; then
		echo
		echo "Too many arguments : $#"
		PrintHelp
		exit 128
	fi

	if [ "$1" = "--help" ]; then
		PrintHelp
	fi

	# Writing message if parameter -n
	if [ "$1" = "-n" ]; then

		if [ $# -eq 1 ]; then
			CreateFile
		fi

		# If there is a number of days skip ahead by that much
		if [ $# -eq 2 ]; then

			# Test to see if number is a positive integer
			if [[ $2 =~ ^[+]?[0-9]+$ ]]; then
				CreateFile $2
			else
				echo Invalid parameter for -n option
				PrintHelp
			fi
		fi
	fi
fi
